{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../src/platform/guided-tour/guided.tour.ts","../../../../src/platform/guided-tour/guided-tour.service.ts","../../../../src/platform/guided-tour/guided-tour.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","pop","length","push","__read","o","m","r","i","ar","error","__spread","arguments","concat","ITourEvent","click","pointerover","keyup","added","removed","TourButtonsActions","overriddenEvents","keyEvents","Map","defaultStepOptions","scrollTo","behavior","block","cancelIcon","enabled","MAT_ICON_BUTTON","MAT_BUTTON_INVISIBLE","CovalentGuidedTour","stepOptions","_this","_super","newTour","opts","shepherdTour","Shepherd","Tour","assign","_destroyedEvent$","Subject","merge","fromEvent","pipe","first","subscribe","complete","abortOn","abortArr$_1","forEach","abortEvent$","_bindEvent","undefined","abortSubs_1","takeUntil","unsubscribe","back","cancel","finish","addSteps","steps","_prepareTour","start","originalSteps","finishLabel","backEvent$","forwardEvent$","_backFlow","destroyedEvent$","appendProgressFunc","footers","from","document","querySelectorAll","footer","progress","createElement","className","innerText","currentStep","options","count","stepTotal","insertBefore","querySelector","map","showProgress","_a","attachToOptions","skipFromStepCount","_b","_c","bind","when","show","finishButton","text","action","classes","voidButton","totalSteps","index","nextButton","backButton","goBackTo","advanceOnOptions","allowGoBack","highlightClass","highlight","buttons","advanceOn","isArray","indexOf","event","split","beforeShowPromise","id","_stopTimer$","_retriesReached$","_retryAttempts$","BehaviorSubject","attachTo","element","getCurrentStep","updateStepOptions","skip","asObservable","skipWhile","val","retries","attempts","skipIfNotFound","destroy","removeStep","else","console","warn","timer","timeBeforeShow","interval","advanceArr$_1","advanceEvent$","advanceSubs_1","forkJoin","jumpTo","abortArr$_2","abortSubs_2","additionalCapabilitiesSetup","eventOn","eventOnOptions","event$","selector","timerSubs","mainEvent","subEvent_1","filter","$event","KeyboardEvent","get","keyCode","observer_1","MutationObserver","contains","disconnect","observe","childList","subtree","attributes","TourEvents","hide","active","inactive","CovalentGuidedTourService","_router","_route","_httpClient","_toursMap","_tourStepURLs","events","NavigationStart","navigationTrigger","isActive","tourEvent$","str","registerTour","tourName","tour","_loadTour","guidedTour","set","startTour","_getTour","tourInstance","_configureRoutesForSteps","finishButtonText","tourEvent","currentURL","url","has","stepRoute","navigate","routing","route","initializeOnQueryParams","queryParam","queryParamMap","debounceTime","tap","params","tourParam","searchParams","URLSearchParams","window","location","search","delete","protocol","host","pathname","toString","history","replaceState","path","tourUrl","request","resultSet","JSON","parse","stringify","toPromise","key","routedSteps","route_1","beforeShowPromise_1","extras","Injectable","Router","ActivatedRoute","HttpClient","NgModule","args","imports","CommonModule","providers","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import Shepherd from 'shepherd.js';\nimport { timer, Subject, BehaviorSubject, merge, Subscription, fromEvent, forkJoin } from 'rxjs';\nimport { takeUntil, skipWhile, filter, skip, first } from 'rxjs/operators';\n\nexport type TourStep = Shepherd.Step.StepOptions;\nexport type TourStepButton = Shepherd.Step.StepOptionsButton;\n\nexport enum ITourEvent {\n  'click' = 'click',\n  'pointerover' = 'pointerover',\n  'keyup' = 'keyup',\n  'added' = 'added', // added to DOM\n  'removed' = 'removed', // removed from DOM\n}\n\nexport interface ITourEventOn {\n  selector?: string; // css selector\n  event?: keyof typeof ITourEvent; // click, pointerover, keyup, added, removed\n}\n\nexport interface ITourEventOnOptions {\n  timeBeforeShow?: number; // delay before step is displayed\n  interval?: number; // time between searches for element, defaults to 500ms\n}\n\nexport interface ITourAbortOn extends ITourEventOn {}\n\nexport interface ITourOptions extends Shepherd.Tour.TourOptions {\n  abortOn?: ITourAbortOn[]; // events to abort on\n}\n\nexport interface ITourStepAttachToOptions extends ITourEventOnOptions {\n  highlight?: boolean;\n  retries?: number; // # num of attempts to find element\n  skipIfNotFound?: boolean; // if element is not found after n retries, move on to next step\n  else?: string; // if element is not found, go to step with this id\n  goBackTo?: string; // back button goes back to step with this id\n  skipFromStepCount?: boolean; // show/hide progress on step\n}\n\nexport interface ITourStepAdvanceOn extends ITourEventOn {}\n\nexport interface ITourStepAdvanceOnOptions extends ITourEventOnOptions {\n  jumpTo?: string; // next button will jump to step with this id\n  allowGoBack?: boolean; // allow back within this step\n}\n\nexport interface ITourStep extends TourStep {\n  attachToOptions?: ITourStepAttachToOptions;\n  advanceOnOptions?: ITourStepAdvanceOnOptions;\n  advanceOn?: ITourStepAdvanceOn[] | ITourStepAdvanceOn | any;\n  abortOn?: ITourAbortOn[];\n  count?: number;\n}\n\nabstract class TourButtonsActions {\n  abstract next(): void;\n\n  abstract back(): void;\n\n  abstract cancel(): void;\n\n  abstract finish(): void;\n}\n\nconst SHEPHERD_DEFAULT_FIND_TIME_BEFORE_SHOW: number = 100;\nconst SHEPHERD_DEFAULT_FIND_INTERVAL: number = 500;\nconst SHEPHERD_DEFAULT_FIND_ATTEMPTS: number = 20;\n\nconst overriddenEvents: string[] = [\n  ITourEvent.click,\n  ITourEvent.pointerover,\n  ITourEvent.removed,\n  ITourEvent.added,\n  ITourEvent.keyup,\n];\n\nconst keyEvents: Map<number, string> = new Map<number, string>([\n  [13, 'enter'],\n  [27, 'esc'],\n]);\n\nconst defaultStepOptions: TourStep = {\n  scrollTo: { behavior: 'smooth', block: 'center' },\n  cancelIcon: {\n    enabled: true,\n  },\n};\n\nconst MAT_ICON_BUTTON: string = 'mat-icon-button material-icons mat-button-base';\nconst MAT_BUTTON: string = 'mat-button-base mat-button';\nconst MAT_BUTTON_INVISIBLE: string = 'shepherd-void-button';\n\nexport class CovalentGuidedTour extends TourButtonsActions {\n  private _destroyedEvent$: Subject<void>;\n\n  shepherdTour: Shepherd.Tour;\n  stepOptions: ITourStep;\n\n  constructor(stepOptions: ITourStep = defaultStepOptions) {\n    super();\n\n    this.stepOptions = stepOptions;\n    this.newTour();\n  }\n\n  newTour(opts?: ITourOptions): void {\n    this.shepherdTour = new Shepherd.Tour(\n      Object.assign(\n        {\n          defaultStepOptions: this.stepOptions,\n        },\n        opts,\n      ),\n    );\n\n    this._destroyedEvent$ = new Subject<void>();\n    // listen to cancel and complete to clean up abortOn events\n    merge(fromEvent(this.shepherdTour, 'cancel'), fromEvent(this.shepherdTour, 'complete'))\n      .pipe(first())\n      .subscribe(() => {\n        this._destroyedEvent$.next();\n        this._destroyedEvent$.complete();\n      });\n\n    // if abortOn was passed, we bind the event and execute complete\n    if (opts && opts.abortOn) {\n      const abortArr$: Subject<void>[] = [];\n      opts.abortOn.forEach((abortOn: ITourAbortOn) => {\n        const abortEvent$: Subject<void> = new Subject<void>();\n        abortArr$.push(abortEvent$);\n        this._bindEvent(abortOn, undefined, abortEvent$, this._destroyedEvent$);\n      });\n\n      const abortSubs: Subscription = merge(...abortArr$)\n        .pipe(takeUntil(this._destroyedEvent$))\n        .subscribe(() => {\n          this.shepherdTour.complete();\n          abortSubs.unsubscribe();\n        });\n    }\n  }\n\n  back(): void {\n    this.shepherdTour.back();\n  }\n\n  cancel(): void {\n    this.shepherdTour.cancel();\n  }\n\n  next(): void {\n    this.shepherdTour.next();\n  }\n\n  finish(): void {\n    this.shepherdTour.complete();\n  }\n\n  addSteps(steps: ITourStep[]): void {\n    this.shepherdTour.addSteps(this._prepareTour(steps));\n  }\n\n  start(): void {\n    this.shepherdTour.start();\n  }\n\n  protected _prepareTour(originalSteps: ITourStep[], finishLabel: string = 'finish'): ITourStep[] {\n    // create Subjects for back and forward events\n    const backEvent$: Subject<void> = new Subject<void>();\n    const forwardEvent$: Subject<void> = new Subject<void>();\n    let _backFlow: boolean = false;\n    // create Subject for your end\n    const destroyedEvent$: Subject<void> = new Subject<void>();\n    /**\n     * This function adds the step progress in the footer of the shepherd tooltip\n     */\n    const appendProgressFunc: Function = function (): void {\n      // get all the footers that are available in the DOM\n      const footers: Element[] = Array.from<Element>(document.querySelectorAll('.shepherd-footer'));\n      // get the last footer since Shepherd always puts the active one at the end\n      const footer: Element = footers[footers.length - 1];\n      // generate steps html element\n      const progress: HTMLSpanElement = document.createElement('span');\n      progress.className = 'shepherd-progress';\n      progress.innerText = `${this.shepherdTour.currentStep.options.count}/${stepTotal}`;\n      // insert into the footer before the first button\n      footer.insertBefore(progress, footer.querySelector('.shepherd-button'));\n    };\n\n    let stepTotal: number = 0;\n    const steps: ITourStep[] = originalSteps.map((step: ITourStep) => {\n      let showProgress: Function;\n      if (step.attachToOptions?.skipFromStepCount === true) {\n        showProgress = function (): void {\n          return;\n        };\n      } else if (\n        step.attachToOptions?.skipFromStepCount === undefined ||\n        step.attachToOptions?.skipFromStepCount === false\n      ) {\n        step.count = ++stepTotal;\n        showProgress = appendProgressFunc.bind(this);\n      }\n      return Object.assign({}, step, {\n        when: {\n          show: showProgress,\n        },\n      });\n    });\n\n    const finishButton: TourStepButton = {\n      text: finishLabel,\n      action: this['finish'].bind(this),\n      classes: MAT_BUTTON,\n    };\n\n    const voidButton: TourStepButton = {\n      text: '',\n      action(): void {\n        return;\n      },\n      classes: MAT_BUTTON_INVISIBLE,\n    };\n\n    // listen to the destroyed event to clean up all the streams\n    this._destroyedEvent$.pipe(first()).subscribe(() => {\n      backEvent$.complete();\n      forwardEvent$.complete();\n      destroyedEvent$.next();\n      destroyedEvent$.complete();\n    });\n\n    const totalSteps: number = steps.length;\n    steps.forEach((step: ITourStep, index: number) => {\n      // create buttons specific for the step\n      // this is done to create more control on events\n      const nextButton: TourStepButton = {\n        text: 'chevron_right',\n        action: () => {\n          // intercept the next action and trigger event\n          forwardEvent$.next();\n          this.shepherdTour.next();\n        },\n        classes: MAT_ICON_BUTTON,\n      };\n      const backButton: TourStepButton = {\n        text: 'chevron_left',\n        action: () => {\n          // intercept the back action and trigger event\n          backEvent$.next();\n          _backFlow = true;\n          // check if 'goBackTo' is set to jump to a particular step, else just go back\n          if (step.attachToOptions && step.attachToOptions.goBackTo) {\n            this.shepherdTour.show(step.attachToOptions.goBackTo, false);\n          } else {\n            this.shepherdTour.back();\n          }\n        },\n        classes: step.advanceOnOptions?.allowGoBack === false ? MAT_BUTTON_INVISIBLE : MAT_ICON_BUTTON,\n      };\n\n      // check if highlight was provided for the step, else fallback into shepherds usage\n      step.highlightClass =\n        step.attachToOptions && step.attachToOptions.highlight ? 'shepherd-highlight' : step.highlightClass;\n\n      if (index === 0) {\n        // first step\n        step.buttons = [nextButton];\n      } else if (index === totalSteps - 1) {\n        // last step\n        step.buttons = [backButton, finishButton];\n      } else {\n        step.buttons = [backButton, nextButton];\n      }\n\n      // checks \"advanceOn\" to override listeners\n      let advanceOn: ITourStepAdvanceOn[] | ITourStepAdvanceOn = step.advanceOn;\n      // remove the shepherd \"advanceOn\" infavor of ours if the event is part of our list\n      if (\n        (typeof advanceOn === 'object' &&\n          !Array.isArray(advanceOn) &&\n          overriddenEvents.indexOf(advanceOn.event.split('.')[0]) > -1) ||\n        advanceOn instanceof Array\n      ) {\n        step.advanceOn = undefined;\n        step.buttons =\n          step.advanceOnOptions && step.advanceOnOptions.allowGoBack ? [backButton, voidButton] : [voidButton];\n      }\n      // adds a default beforeShowPromise function\n      step.beforeShowPromise = () => {\n        return new Promise((resolve: () => void) => {\n          const additionalCapabilitiesSetup: Function = () => {\n            if (advanceOn && !step.advanceOn) {\n              if (!Array.isArray(advanceOn)) {\n                advanceOn = [advanceOn];\n              }\n\n              const advanceArr$: Subject<void>[] = [];\n              advanceOn.forEach((_: any, i: number) => {\n                const advanceEvent$: Subject<void> = new Subject<void>();\n                advanceArr$.push(advanceEvent$);\n                // we start a timer of attempts to find an element in the dom\n                this._bindEvent(advanceOn[i], step.advanceOnOptions, advanceEvent$, destroyedEvent$);\n              });\n              const advanceSubs: Subscription = forkJoin(...advanceArr$)\n                .pipe(takeUntil(merge(destroyedEvent$, backEvent$)))\n                .subscribe(() => {\n                  // check if we need to advance to a specific step, else advance to next step\n                  if (step.advanceOnOptions && step.advanceOnOptions.jumpTo) {\n                    this.shepherdTour.show(step.advanceOnOptions.jumpTo);\n                  } else {\n                    this.shepherdTour.next();\n                  }\n                  forwardEvent$.next();\n                  advanceSubs.unsubscribe();\n                });\n            }\n\n            // if abortOn was passed on the step, we bind the event and execute complete\n            if (step.abortOn) {\n              const abortArr$: Subject<void>[] = [];\n              step.abortOn.forEach((abortOn: ITourAbortOn) => {\n                const abortEvent$: Subject<void> = new Subject<void>();\n                abortArr$.push(abortEvent$);\n                this._bindEvent(abortOn, undefined, abortEvent$, destroyedEvent$);\n              });\n\n              const abortSubs: Subscription = merge(...abortArr$)\n                .pipe(takeUntil(merge(destroyedEvent$, backEvent$, forwardEvent$)))\n                .subscribe(() => {\n                  this.shepherdTour.complete();\n                  abortSubs.unsubscribe();\n                });\n            }\n          };\n\n          const _stopTimer$: Subject<void> = new Subject<void>();\n          const _retriesReached$: Subject<number> = new Subject<number>();\n          const _retryAttempts$: BehaviorSubject<number> = new BehaviorSubject<number>(-1);\n\n          let id: string;\n          // checks if \"attachTo\" is a string or an object to get the id of an element\n          if (typeof step.attachTo === 'string') {\n            id = step.attachTo;\n          } else if (typeof step.attachTo === 'object' && typeof step.attachTo.element === 'string') {\n            id = step.attachTo.element;\n          }\n          // if we have an id as a string in either case, we use it (we ignore it if its HTMLElement)\n          if (id) {\n            // if current step is the first step of the tour, we set the buttons to be only \"next\"\n            // we had to use `any` since the tour doesnt expose the steps in any fashion nor a way to check if we have modified them at all\n            if (this.shepherdTour.getCurrentStep() === (<any>this.shepherdTour).steps[0]) {\n              this.shepherdTour.getCurrentStep().updateStepOptions({\n                buttons: originalSteps[index].advanceOn ? [voidButton] : [nextButton],\n              });\n            }\n            // register to the attempts observable to notify deeveloper when number has been reached\n            _retryAttempts$\n              .pipe(\n                skip(1),\n                takeUntil(merge(_stopTimer$.asObservable(), destroyedEvent$)),\n                skipWhile((val: number) => {\n                  if (step.attachToOptions && step.attachToOptions.retries !== undefined) {\n                    return val < step.attachToOptions.retries;\n                  }\n                  return val < SHEPHERD_DEFAULT_FIND_ATTEMPTS;\n                }),\n              )\n              .subscribe((attempts: number) => {\n                _retriesReached$.next();\n                _retriesReached$.complete();\n                // if attempts have been reached, we check \"skipIfNotFound\" to move on to the next step\n                if (step.attachToOptions && step.attachToOptions.skipIfNotFound) {\n                  // if we get to this step coming back from a step and it wasnt found\n                  // then we either check if its the first step and try going forward\n                  // or we keep going back until we find a step that actually exists\n                  if (_backFlow) {\n                    if ((<any>this.shepherdTour).steps.indexOf(this.shepherdTour.getCurrentStep()) === 0) {\n                      this.shepherdTour.next();\n                    } else {\n                      this.shepherdTour.back();\n                    }\n                    _backFlow = false;\n                  } else {\n                    // destroys current step if we need to skip it to remove it from the tour\n                    const currentStep: Shepherd.Step = this.shepherdTour.getCurrentStep();\n                    currentStep.destroy();\n                    this.shepherdTour.next();\n                    this.shepherdTour.removeStep((<Shepherd.Step.StepOptions>currentStep).id);\n                  }\n                } else if (step.attachToOptions && step.attachToOptions.else) {\n                  // if \"skipIfNotFound\" is not true, then we check if \"else\" has been set to jump to a specific step\n                  this.shepherdTour.show(step.attachToOptions.else);\n                } else {\n                  // tslint:disable-next-line:no-console\n                  console.warn(`Retries reached trying to find ${id}. Retried  ${attempts} times.`);\n                  // else we show the step regardless\n                  resolve();\n                }\n              });\n\n            // we start a timer of attempts to find an element in the dom\n            timer(\n              (step.attachToOptions && step.attachToOptions.timeBeforeShow) || SHEPHERD_DEFAULT_FIND_TIME_BEFORE_SHOW,\n              (step.attachToOptions && step.attachToOptions.interval) || SHEPHERD_DEFAULT_FIND_INTERVAL,\n            )\n              .pipe(\n                // the timer will continue either until we find the element or the number of attempts has been reached\n                takeUntil(merge(_stopTimer$, _retriesReached$, destroyedEvent$)),\n              )\n              .subscribe(() => {\n                const element: HTMLElement = document.querySelector(id);\n                // if the element has been found, we stop the timer and resolve the promise\n                if (element) {\n                  _stopTimer$.next();\n                  _stopTimer$.complete();\n                  additionalCapabilitiesSetup();\n                  resolve();\n                } else {\n                  _retryAttempts$.next(_retryAttempts$.value + 1);\n                }\n              });\n\n            // stop find interval if user stops the tour\n            destroyedEvent$.subscribe(() => {\n              _stopTimer$.next();\n              _stopTimer$.complete();\n              _retriesReached$.next();\n              _retriesReached$.complete();\n            });\n          } else {\n            // resolve observable until the timeBeforeShow has passsed or use default\n            timer(\n              (step.attachToOptions && step.attachToOptions.timeBeforeShow) || SHEPHERD_DEFAULT_FIND_TIME_BEFORE_SHOW,\n            )\n              .pipe(takeUntil(merge(destroyedEvent$)))\n              .subscribe(() => {\n                resolve();\n              });\n          }\n        });\n      };\n    });\n    return steps;\n  }\n\n  private _bindEvent(\n    eventOn: ITourEventOn,\n    eventOnOptions: ITourEventOnOptions,\n    event$: Subject<void>,\n    destroyedEvent$: Subject<void>,\n  ): void {\n    const selector: string = eventOn.selector;\n    const event: string = eventOn.event;\n    // we start a timer of attempts to find an element in the dom\n    const timerSubs: Subscription = timer(\n      (eventOnOptions && eventOnOptions.timeBeforeShow) || SHEPHERD_DEFAULT_FIND_TIME_BEFORE_SHOW,\n      (eventOnOptions && eventOnOptions.interval) || SHEPHERD_DEFAULT_FIND_INTERVAL,\n    )\n      .pipe(takeUntil(destroyedEvent$))\n      .subscribe(() => {\n        const element: HTMLElement = document.querySelector(selector);\n        // if the element has been found, we stop the timer and resolve the promise\n        if (element) {\n          timerSubs.unsubscribe();\n\n          if (event === ITourEvent.added) {\n            // if event is \"Added\" trigger a soon as this is attached.\n            event$.next();\n            event$.complete();\n          } else if (\n            event === ITourEvent.click ||\n            event === ITourEvent.pointerover ||\n            event.indexOf(ITourEvent.keyup) > -1\n          ) {\n            // we use normal listeners for mouseevents\n            const mainEvent: string = event.split('.')[0];\n            const subEvent: string = event.split('.')[1];\n            fromEvent(element, mainEvent)\n              .pipe(\n                takeUntil(merge(event$.asObservable(), destroyedEvent$)),\n                filter(($event: Event) => {\n                  // only trigger if the event is a keyboard event and part of out list\n                  if ($event instanceof KeyboardEvent) {\n                    if (keyEvents.get($event.keyCode) === subEvent) {\n                      return true;\n                    }\n                    return false;\n                  } else {\n                    return true;\n                  }\n                }),\n              )\n              .subscribe(() => {\n                event$.next();\n                event$.complete();\n              });\n          } else if (event === ITourEvent.removed) {\n            // and we will use MutationObserver for DOM events\n            const observer: MutationObserver = new MutationObserver(() => {\n              if (!document.body.contains(element)) {\n                event$.next();\n                event$.complete();\n                observer.disconnect();\n              }\n            });\n\n            // stop listenining if tour is closed\n            destroyedEvent$.subscribe(() => {\n              observer.disconnect();\n            });\n            // observe for any DOM interaction in the element\n            observer.observe(element, { childList: true, subtree: true, attributes: true });\n          }\n        }\n      });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport {\n  Router,\n  ActivatedRoute,\n  ParamMap,\n  NavigationExtras,\n  NavigationStart,\n  Event as NavigationEvent,\n} from '@angular/router';\nimport Shepherd from 'shepherd.js';\nimport { tap, map, filter } from 'rxjs/operators';\nimport { Observable, fromEvent } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { CovalentGuidedTour, ITourStep, ITourOptions } from './guided.tour';\n\nexport interface IGuidedTour extends ITourOptions {\n  steps: IGuidedTourStep[];\n  finishButtonText?: string;\n}\n\nexport interface IGuidedTourStep extends ITourStep {\n  routing?: {\n    route: string;\n    extras?: NavigationExtras;\n  };\n}\n\n/**\n *  Router enabled Shepherd tour\n */\nexport enum TourEvents {\n  complete = 'complete',\n  cancel = 'cancel',\n  hide = 'hide',\n  show = 'show',\n  start = 'start',\n  active = 'active',\n  inactive = 'inactive',\n}\n\nexport interface IGuidedTourEvent {\n  step: any;\n  previous: any;\n  tour: any;\n}\n\n@Injectable()\nexport class CovalentGuidedTourService extends CovalentGuidedTour {\n  private _toursMap: Map<string, IGuidedTour> = new Map<string, IGuidedTour>();\n  private _tourStepURLs: Map<string, string> = new Map<string, string>();\n  constructor(private _router: Router, private _route: ActivatedRoute, private _httpClient: HttpClient) {\n    super();\n    _router.events\n      .pipe(\n        filter((event: NavigationEvent) => event instanceof NavigationStart && event.navigationTrigger === 'popstate'),\n      )\n      .subscribe((event: NavigationEvent) => {\n        if (this.shepherdTour.isActive) {\n          this.shepherdTour.cancel();\n        }\n      });\n  }\n\n  tourEvent$(str: TourEvents): Observable<IGuidedTourEvent> {\n    return fromEvent(this.shepherdTour, str);\n  }\n\n  async registerTour(tourName: string, tour: IGuidedTour | string): Promise<void> {\n    const guidedTour: IGuidedTour = typeof tour === 'string' ? await this._loadTour(tour) : tour;\n    this._toursMap.set(tourName, guidedTour);\n  }\n\n  startTour(tourName: string): Shepherd.Tour {\n    const guidedTour: IGuidedTour = this._getTour(tourName);\n    this.finish();\n    if (guidedTour && guidedTour.steps && guidedTour.steps.length) {\n      // remove steps from tour since we need to preprocess them first\n      this.newTour(Object.assign({}, guidedTour, { steps: undefined }));\n      const tourInstance: Shepherd.Tour = this.shepherdTour.addSteps(\n        this._configureRoutesForSteps(this._prepareTour(guidedTour.steps, guidedTour.finishButtonText)),\n      );\n      // init route transition if step URL is different then the current location.\n      this.tourEvent$(TourEvents.show).subscribe((tourEvent: IGuidedTourEvent) => {\n        const currentURL: string = this._router.url.split(/[?#]/)[0];\n        const {\n          step: { id, options },\n        } = tourEvent;\n        if (this._tourStepURLs.has(id)) {\n          const stepRoute: string = this._tourStepURLs.get(id);\n          if (stepRoute !== currentURL) {\n            this._router.navigate([stepRoute]);\n          }\n        } else {\n          if (options && options.routing) {\n            this._tourStepURLs.set(id, options.routing.route);\n          } else {\n            this._tourStepURLs.set(id, currentURL);\n          }\n        }\n      });\n      this.start();\n      return tourInstance;\n    } else {\n      // tslint:disable-next-line:no-console\n      console.warn(`Tour ${tourName} does not exist. Please try another tour.`);\n    }\n  }\n\n  // Finds the right registered tour by using queryParams\n  // finishes any other tour and starts the new one.\n  initializeOnQueryParams(queryParam: string = 'tour'): Observable<ParamMap> {\n    return this._route.queryParamMap.pipe(\n      debounceTime(100),\n      tap((params: ParamMap) => {\n        const tourParam: string = params.get(queryParam);\n        if (tourParam) {\n          this.startTour(tourParam);\n          // get current search parameters\n          const searchParams: URLSearchParams = new URLSearchParams(window.location.search);\n          // delete tour queryParam\n          searchParams.delete(queryParam);\n          // build new URL string without it\n          let url: string = window.location.protocol + '//' + window.location.host + window.location.pathname;\n          if (searchParams.toString()) {\n            url += '?' + searchParams.toString();\n          }\n          // replace state in history without triggering a navigation\n          window.history.replaceState({ path: url }, '', url);\n        }\n      }),\n    );\n  }\n\n  private async _loadTour(tourUrl: string): Promise<any> {\n    const request: Observable<object> = this._httpClient.get(tourUrl);\n    try {\n      return await request\n        .pipe(\n          map((resultSet: any) => {\n            return JSON.parse(JSON.stringify(resultSet));\n          }),\n        )\n        .toPromise();\n    } catch {\n      return undefined;\n    }\n  }\n\n  private _getTour(key: string): IGuidedTour {\n    return this._toursMap.get(key);\n  }\n\n  private _configureRoutesForSteps(routedSteps: IGuidedTourStep[]): IGuidedTourStep[] {\n    routedSteps.forEach((step: IGuidedTourStep) => {\n      if (step.routing) {\n        const route: string = step.routing.route;\n        // if there is a beforeShowPromise, then we save it and call it after the navigation\n        if (step.beforeShowPromise) {\n          const beforeShowPromise: () => Promise<void> = step.beforeShowPromise;\n          step.beforeShowPromise = () => {\n            return this._router.navigate([route], step.routing.extras).then(() => {\n              return beforeShowPromise();\n            });\n          };\n        } else {\n          step.beforeShowPromise = () => this._router.navigate([route]);\n        }\n      }\n    });\n\n    return routedSteps;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CovalentGuidedTourService } from './guided-tour.service';\n\n@NgModule({\n  imports: [CommonModule],\n  providers: [CovalentGuidedTourService],\n  declarations: [],\n  exports: [],\n})\nexport class CovalentGuidedTourModule {}\n"]}